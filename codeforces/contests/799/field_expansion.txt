First, we only have to consider 34 extensions, because log2 100000 rounds up to 17, and there are two sides.
 - Clearly, we want the largest 34.
We also need to consider if we want to rotate the original field before expansion.
 - It may seem like we want to match the shorter sides to the shorter sides and vice versa, but this actually doesn't work.
 - There might be a faster solution, but we can simply just try both orientations and take the minimum.
 - Here is a test case illustrating this: 43829 19653 2 1 34; all extensions are 4
 - Matching 43829 to 2, it takes 16, but matching it to 1 it only takes 15.

We can then use knapsack dp to find all possible subsets. However, two issues remain:
1) How do we ensure we use the minimum amount of extensions, given we can't store all the subsets?
2) How do we calculate the second factor (width/height) given the first?

1) We can prove that the minimum # of extensions used (denoted K) are going to always be the K largest extensions.
If we can't achieve it with all K-1, then it is impossible to achieve it with only K-1 of the K extensions.
Therefore, we can just do a knapsack starting from the largest extensions, and stop once we get a valid answer.

2) Note that the subset doesn't matter; if we have K as the product of all extensions considered so far and have used up a product of P, then we have K/P leftover.
But K will very easily overflow; it also doesn't help to cap it at some value.
The first observation we can make is that any P over 100,000 is unnecessary, and we only have to store the minimum P greater than that.
Second, we can store some arbitrary subset multiplying to P with bits - which subset doesn't matter, as long as the product is P.
Then the leftover is the product of the bits that are turned off (turned off = unused, on = used in product P).
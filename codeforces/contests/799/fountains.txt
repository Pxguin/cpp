There are three cases:
 - Buy one with coins & one with diamonds
 - Buy both with coins
 - Buy both with diamonds

We can consider each separately. First, we can sort the fountains into two arrays (coins & diamonds).

Case 1:
Take the fountain with the max beauty (and a cost under the budget) from both arrays


Case 2:
We want to, for every fountain, find the ones that can be bought as well.
More formally, for every fountain X, find all fountains Y such that X.p+Y.p <= C, where .p denotes the price and C is the budget.
Then, we take the maximum beauty from all suitable fountain Y.

Normally it takes O(N^2), but with the help of a monotonic stack (vector in my solution) it takes O(N).
 - A similar application is used in USACO 2018 Feb Gold: Snow Boots, and Cow Frisbee from 2022 Jan Silver.
Then, we can use prefix maxima to find the max beauty.

However, there is the special (and annoying) rule that we can't build the same fountain twice.

In other words, the issue is that the maximum value might link back to the current fountain that we are checking,
which results in the same fountain being built two times.

To solve this, we can figure out the prefix first and second maximums, and take the second maximum if the first links to the current one.


Case 3: 
Repeat case 2, but for diamonds.


Code:
It is definitely possible to calculate the max values for case 1 while calculating the other cases (simultaneously).
The editorial solution is easier in that it splits up the two cases:
X.p = Y.p (which takes care of building the same fountain twice)
X.p < Y.p (every other fountain)
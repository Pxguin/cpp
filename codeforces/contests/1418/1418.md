# Edu Codeforces Round 95 (#1418)

## G. Three Occurences
It's easier to solve the problem when the occurence of every integer is a multiple of $3$. In fact, this is pretty much just <b>AtCoder - Cubic?</b> I hashed with dot product that time, but this time I did it with a modification of xor. Basically, we want a hash that, when applied a multiple of $3$ times, is the same thing as doing nothing (so it loops for multiples of $3$). If we wanted it to loop after a multiple of $2$, then just assign a random number and use xor; for $3$, we want to generate two random numbers $A$ and $B$. We use $A$ at the first occurence of a number, $B$ at the second, and $A\oplus{B}$ at the third. This works because $A\oplus{B}\oplus(A\oplus{B})=0$. Call this hash for an index $H_i$. We can say, then, that all numbers in any subarray $[L,R]$ appear a multiple of three times if $H_L\oplus{H_{L+1}}\oplus\dots\oplus{H_R}=0$. Take the prefix xor $P_i$, so all that is left to check is $P_R=P_{L-1}$. 

<b>TLDR; read the editorial for Cubic.</b>

Now to check if every element occurs exactly $3$ times instead of a multiple, we can keep track of the last three occurences of every number, which in turn lets us calculate, for every left endpoint, the maximum right endpoint before a number inevitably occurs $>3$ times (call it $M$). To calculate the answer, we can group all equal hashes, as a valid range has equal hashes for the left and right endpoints. We have to make sure that the right endpoint is before $M_L$ though, which can be done with a set or 2 pointers. So it's $O(NlogN)$, or $O(N)$ (which my solution is).
# Codeforces Round 443 (#878)

## C. Tournament
Impossible problem lol. It's a new hardest; I went through so many solution steps, and I don't really have a better way of explaining the solution rather than going through them one by one.

### Part 1
Draw a directed edge from $A$ to $B$, if $A$ can beat $B$ at some sport (i.e., $B$ can be eliminated by $A$). For the resulting graph, a node can win the tournament if you can reach all other nodes through a DFS from this source. We can condense the graph into the strongly connected components, which will be the base of the whole problem, and note that the answer is the size of the SCC with indegree $0$.

### Part 2
For every SCC, it's only necessary to store the maximum and minimum skill levels for each sport - we can tell whether an edge exists between two SCCs simply by comparing these values. Importantly, in the condensation of the graph, between any two SCCs there will only exist one directional edge - if there is a bidirectional edge then they should have been merged into a single SCC. From this, we can conclude that SCCs completely dominate one another, or that for two SCCs $A$ and $B$, $B$ can never beat $A$ or vice versa. This observation is important because it allows us to sort all SCCs and put them into a set. It follows that for every adjacent pair of SCCs in the set, there is a single directed edge from the second SCC to the first. Also, instead of the answer being the size of the SCC with indegree $0$, it can be simplified to the size of the most dominant SCC (last element in the set).

### Part 3
When we add a new contestant, we add a new node and new edges, then we have to recalculate SCCs. Note that if adding the node $X$ creates a cycle between multiple SCCs, then all those SCCs will be merged together. The SCCs being merged is all of the subsequence $[A,B]$ (in the set), such that $A$ is the first node that can beat $X$ and $B$ is the last node that $X$ can beat. This implies the edges $A\rightarrow{X}$ and $X\rightarrow{B}$, and there are already edges from $B$ to $A$, so this will always form a cycle. So now, the question is how to find $A$ and $B$. It would suffice to use custom comparators with binary search, but unfortunately there's no efficient way to do that (I tried, my original functions were upper, lower, and cmp, which you can see in the code). The editorial mentions a search tree but you can also just unionize all these comparators to a single one, and make use of lower and upper bound to achieve the result. The time complexity is $O(NKlogN)$.
# Codeforces Round 1004 (#2065)

## F. Skibidus and Slay
A path is a good path for $i$ if $i$ is the majority. WLOG assume $i=1$. If some path is a good path, then there always exists a good subarray of that path of the form $[1,x,1]$ or $[1,1]$ for any other integer $x$. So we only need to consider groups of three adjacent vertices, which is done with a simple dfs in $O(N)$.

Some intuition on why the path is always reducible comes from a dp. Transform all occurences of $i$ to have weight $1$ and all others to have weight $-1$, then do a dfs in the tree; if there exists a path between two occurences of $i$ with a positive sum of vertices, then $i$ is the majority. As for transitions, it's clear that at any point we can increase the length of an existing path/start a new path, or end a path if the vertex sum is positive. If the vertex sum for a path ending at some node $j$ ($a_j=i$) is $\le{0}$, then that path is useless and we can discard it. So we can say for our dp that any good path must contain exactly two occurences of $i$ (at its endpoints), which means that the path is either $[i,x,i]$ or $[i,i]$.

## G. Skibidus and Capping
$lcm(a,b)={ab\over{gcd(a,b)}}$. So decompose $a$ and $b$ into their prime factors. $lcm(a,b)$ must have exactly two prime factors, so we can just run casework.
 - If for a pair $(i,j)$, $a_i=a_j$ and $a_i$ is semiprime, then $(i,j)$ is valid.
 - If $a_i$ is prime and $a_j$ is a prime multiple of $a_i$, then it's valid.
 - If $a_i$ and $a_j$ are primes, then it's valid.

After precalculating primes, running the algorithm takes a total of $O(NlogN)$ time.

## H. Bro Thinks He's Him
The dp required is pretty interesting. We will go through every pair $(i,j)$ such that $s_i\ne{s_j}$, meaning that this pair contributes $1$ to any subsequences containing $i$ and $j$ in adjacent order. After fixing $i$ and $j$, there are $2^{i-1}\cdot{2^{n-j}}$ valid subsequences containing these in adjacent order.

We can run some simple dp to calculate the answer. Let $cnt[i][j=0/1]$ be the sum of all $2^k$ for indices $k<i$ satisfying $s_k=j$. WLOG assume $s_i=0$. Then we add $cnt[i][1]\cdot{2^{n-i}}$ to the answer and update $cnt[i+1][0]$ as $cnt[i][0]+2^{i-1}$. Or instead, we can add $2^i$ into a Fenwick tree and then query a prefix sum to retrieve the value of $cnt[i+1][0]$.

For queries, assume WLOG that the index being updated, $i$, satisfies $s_i=0$. First, we want to recalculate this value, by adding $(cnt[i][0]-cnt[i][1])\cdot{2^{n-i}}$ to the answer. Also, we want to subtract $2^{i-1}$ from all future $cnt[j][0]$ ($j>i$) and add $2^{i-1}$ to all future $cnt[j][1]$. Expressing $cnt$ as a prefix sum on a Fenwick tree makes it very easy, and this can all be updated in $O(logN)$.

Next, for $j>i$ and $s_j\ne{s_i}$, after we invert $s_i$ then $s_j$ can no longer pair with it. So for all these indices, we subtract $2^{n-j}\cdot{2^{i-1}}$ from the answer. Same goes for indices $j$ satisfying $s_j=s_i$; we'll add $2^{n-j}\cdot{2^{i-1}}$ to the answer. Maintaining two more suffix sum Fenwick trees to find the sum of all $2^{n-j}$ is very helpful for this, and so the time complexity ends up being $O((N+Q)logN)$.

## Comments:
Off day today, but at least got some practice doing a mock contest. I basically sit down and time myself, and don't leave the area (usually I would solve problems by looking at them and thinking about them while doing other stuff).
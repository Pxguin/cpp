# Refact.ai Match 1/Codeforces Round 985 (#2029)

## E. Common Generator
It feels like $2400$ idk why the rating is only $2100$. But, it is one of my favorite problems :thumbs_up:

First, a prime can't be a generator of another prime. Also, increasing a number by a divisor is the same thing as taking a prime factor of that number and increasing it by $1$. Thus, the numbers able to be generated by a prime number (excluding the prime itself) must be a subset of the numbers generated by any prime numbers smaller than it. So, this means that the answer must be a prime number. Also, we want to consider prime numbers from smallest to largest.

Therefore, if there exist two primes in the array then there is already no solution. If there's only one prime then we simply have to verify whether it can generate all other numbers; if there's no prime then we'll choose the smallest prime, $2$. Call this chosen prime $p$.

Onto how to check if $p$ works:
 - The smallest number that $p$ can generate is $2p$. So if the number $x$ is even, then it works if $x\ge{2p}$ because we can constantly add $2$ to $2p$.
 - If $x$ is odd, then the largest number than generates this number must be $x-d(x)$ where $d$ is equal to the smallest divisor of $x$. This is because $x-d(x)$ must contain $d(x)$ as a divisor; also, it will always be even. So therefore we just check if $x-d(x)\ge{2p}$.

The runtime becomes $O(N)$ when excluding $O((\max{a_i})log(\max{a_i}))$ prime precomputation.

## F. Palindrome Everywhere
Consider a pair $(i,j)$. There is a palindrome route if $(i\pm{1},j\pm{1})$, call it $(i',j')$, is a palindrome, and only if the edges between $(i,i')$ and $(j,j')$ have the same color. This recursive relationship can be applied to $(i',j')$, etc. until we reach a base case pair $(a,b)$ where $a=b$ or $a=b-1$, because those are 100% palindromes. 

This brings us to our first fail case: if we reach some pair $(a,b)$ such that we don't know if it's a palindrome, but can't traverse to any of $(a\pm{1},b\pm{1})$ because none of the edges have the same color. In other words, $a$ lies between $RR$ and $b$ lies between $BB$ (or the other way around). So we can say that if there exists consecutive ranges (of size $\ge{2}$) of both $R$ and $B$, then there is no solution.

Otherwise, we have blocks of arbitrary size of one color, mixed with blocks of size $1$ of the other color. I'll assume WLOG that the first color is $R$ and second is $B$. Some casework should lead to the following conclusions:
 - If there's only one block of color $R$, then return "YES". This is pretty straightforward to see.
 - If all blocks of color $R$ have an odd size, then the answer is "NO". Example: RRRBRB. We can construct the pair $(1,4)$. $1$ is between the first two $Rs$ and $4$ is before the second block of $R$. This is because no matter the moves, the two pointers are forced are forced to rotate to the next blocks of $R$ in the same direction at the same time, meaning they never meet.
 - If there are two or more even size $R$ blocks, then the answer is "NO". Example: RRBRRRRB. Pair: $(1,3)$. Because the sizes are even, we can make it so that the first pointer must always move an odd distance to reach the end of its block while the second pointer must always move an even distance. This means that they will never be able to reach the end of their blocks simultaneously (so they can't rotate blocks and meet).
 - If there is exactly one even size $R$ block, then return "YES". No matter the position of the pointers, we can always get to a point where one pointer is in the even block and the other is in an odd block. This configuration lets us do some maneuvering to get the pointers to leave their blocks in opposite directions, meaning that they will eventually meet.

Calculation takes $O(N)$.
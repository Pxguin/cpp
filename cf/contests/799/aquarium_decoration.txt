This might be the messiest code I've ever written, but this problem is much above what I normally do anyways;
(also pretty much 100% solved it by myself, which is nice)

We can label each decoration as either being liked only by Masha (array A), Arkady (array B), both (C), or no one (D).
We can then split the problem into two parts: calculating the amount needed to satisfy K, then filling up the remaining decorations.
In other words, we choose some subset of size X to satisfy the constraints on K, then choose the remaining minimum M-K decorations.

To solve the first part, I first, to minimize the toll on M, took as many of array C as needed.
 - They contribute the most to K (2) while contributing the least to M (only 1).
Then, we can satisfy K by taking one from arrays A and B, contributing both 2 to K and M.

Now, we need to trade off some of array C for arrays A and B, because the strategy of taking as many as possible may not be optimal.
But it turns out there is no greedy strategy, and we have to simply brute force all possibilities and take the minimum.
 - To do this, I store a set of all remaining, leftover decorations.
 - If we need X more decorations, then we just take the prefix sum of length X from this set to get our minimum.
 - I iterate in descending order on array C, and every time, this adds two elements from A and B to the set, and removes one from array C.
 - Then, I just have to check if the new elements fall into the current range X, and if so update the sum accordingly.

Here are some spots in the code that can be improved:
 - I assign each value in the set an index to make them unique, but they are unnecessary and can be replaced with a multiset.
 - I deepcopy array A and B twice (stored as heaps).
 - This algorithm is more easily done iterating in ascending order over array C, rather than descending like I did.
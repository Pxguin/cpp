# BOI 2009 Day 1

## 1. Beetle
(very cool problem)

The beetle eats a continuous range of water droplets. The equation to calculate for a continuous range $[x_l,x_r]$ is $(M-t_l)+(M-t{l+1})+\dots+(M-t_r)$ where $t_i$ is the time the beetle reaches droplet $i$. We can denote $D$ as the total amount of droplets in the range and rearrange to $DM-\sum_{i=l}^{r}t_i$, so the goal is to minimize the sum of $t_i$ for a fixed $D$.

I'll now present a slow dp that we will optimize. Let $L[l][r][m]$ be the minimum sum of $t_i$ we can achieve for the range $[x_l,x_r]$ assuming the time we reach the last droplet is $m$, and the last droplet we reach is $x_l$ (hence the name of the dp array being $L$. So also make a corresponding $R$ dp array). It should be pretty easy to update this by transitioning from $L[l][r][m]$ to $L[l-1][r][m'_1]$ and $R[l][r+1][m'_2]$, and same for the $R$ array. However, it times out because of the $m$ dimension in the dp array.

Now we optimize by taking advantage of the function corresponding to the sum of $t_i$. Sorting by $t_i$ (i.e. order we eat the droplets), let $d_i=t_{i+1}-t_i$. The sum will then equal to $(D-1)d_i+(D-2)d_{i+1}+\dots+d_{D-1}$. It's easy to see that if we go in reverse, then calculating the $t_i$ sum is possible without having the extra $m$ dimension. Just add the first $d$ value once, the second $d$ value twice, etc. Also, because we are going in reverse, instead of $L[l][r][m]$ representing the beetle having eaten the range $[x_l,x_r]$, it will now represent the beetle eating only from/being restricted to that range in the future (we set it aside for later). Note that going in reverse means that each dp state will no longer implicitly store how many drops we've eaten, so we need to add a dimension $k$ to our dp arrays storing this information.

With this, let $L[l][r][k]$ be the minimum $t$ sum assuming we start at drop $l$, eat $k$ drops, and can't eat anything in the range $[x_l,x_r]$ because we set it aside for the future (aside from $x_l$ because we start here). The next drop is either $l-1$ or $r+1$, so we transition from $L[l-1][r][k-1]$ and $R[l][r+1][k-1]$. For base cases, $L[l][r][1]=R[l][r][1]=0$ for all pairs $(l,r)$. To calculate the answer, we simply look at each value $L[z][z][k]$ where $x_z=0$ and $k$ is anything. The time complexity is $O(N^3)$.
# Balkan OI 2012 Day 1

## 2. Shortest Paths
We can build a tree of shortest paths where there's a directed edge from $i$ to $j$ if the shortest path from $j$ comes from node $i$. Do this from $A$ and $B$. Then when removing an edge from $i$ to $j$, we argue that we know the shortest path from $A$ to anything outside the subtree of $i$, but that anything inside the subtree of $i$ changes. Same goes for $B$ and $j$. Also, the union of everything outside the subtree of $i$ and anything outside the subtree of $j$ must cover all nodes. Candidates for the new shortest path are $distA[i]+D+distB[j]$ where an edge of length $D$ connects two nodes $i$ and $j$ such that the shortest path from $A$ to $i$ and from $B$ to $j$ don't change. Every edge has a certain time-in/time-out range where it is a valid candidate for the shortest path, so calculate these ranges and just use a multiset to select the minimum distance. It runs in $O(MlogN+MlogM)$. The reason the solution is so weird is because I originally thought $N\le{10^5}$. Also note that you don't have to explicitly construct trees with this solution.

My solution considers ties between shortest paths:
If there are ties between shortest paths, then (looking at other solutions, it doesn't seem to matter) break ties by checking the length of the lucky path between the source node ($A$ or $B$) and the root of the deepest subtree that contains this node, such that the root is on the lucky path. The smaller the distance (I give a rank to each one) the better (because it provides a wider time-in/time-out range), unless the node you're comparing it with is preceding this node on the lucky path. Then you haven't found an alternate path of the same length (which was the goal), you've just travelled the lucky path. If you don't need to do this then it's an easy $O(MlogN+MlogM)$ solution.

Update: Rank doesn't matter. I commented out the ambiguous part in Dijkstra and it AC'd with the same runtime. If you want an explanation, there's no need to find an alternate path from a node $Y$ to some node $X$ on the lucky path (edge between $X$ and $Y$, btw), because $Y$ and $X$ will always be in opposite shortest path trees, so you'll consider that candidate path anyways. You could definitely simplify the code further to completely eliminate the rank system but well, it's $O(MlogN+MlogM)$ for sure now.
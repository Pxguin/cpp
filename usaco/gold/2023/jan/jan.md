# USACO Gold 2023 January

## 2. Lights Off
This problem is so difficult and I don't know how the solve rate by promoters was so high. The solution is quite elegant though. Truthfully, most of the problem relies on a fundamental property with xor that was very difficult for me to correctly apply.

If we treat each switch configuration as a node and draw edges, then we want to find a minimum length path from our initial switch state such that the xor of all the nodes on the path is equal to the current light state; this means that all lights are turned off. There's not enough memory or time to precalculate all queries from all states, but it is possible to precalculate them from the one state where all switches and lights are initially turned off (the bitmasks are zero).

Let $dp[i][mask]$ be a boolean that represents if, in exactly $i$ moves, we can get the lights to the state $mask$. It may seem nebulous as how to calculate it but for now we can simply assume that it's possible (I'll explain later). Then for each test case, we're given the light and switch states $L$ and $S$. An upper bound on the number of moves is $3N$, so fix the number of moves $i$. We can pretend that all the switches are initially turned off by taking advantage of the fact that xor is associative. In other words, take the xor of all bitmasks when simulating the process for $i$ moves without flipping the state of any switch (call this xor $X$). Then we check if $dp[i][L\oplus{X}]$ is true.

How to calculate the dp: we will separate all the xors again. If we are on some $dp[i][mask]$, then for each move from $1\dots{i}$, we change the state of some bit. If we look at each bit change individually, the first bit basically turns on a subsequence of length $i$, the second a subsequence of length $i-1$, etc. The xor of all these subsequences is $mask$. So to calculate $dp[i][mask]$, we just try adding a subsequence of length $i$ (denote $X$) at any of the $N$ positions, then check if $dp[i-1][X\oplus{mask}]$ is true. All this will achieve an $O(N^2*2^N+TN)$ runtime.

## 3. Moo Route
Sad that I missed that it was a dp. Once I saw that it was a dp from a solution then it became really clear to me.

Each $a_i$ value must be comprised of $a_i/2$ R's and $a_i/2$ L's, so divide each $a_i$ by $2$. Now let $dp[i]$ be the amount of ways to create a valid route with the minimum number of direction changes, given that we have considered all $a_j$ with $j\in[i,N]$.

We can treat the current route as a mountain range. To extend a mountain range from $dp[i+1]$ to $dp[i]$, our goal is to add $a_i$ upstrokes and $a_i$ downstrokes, each from $y=i$ to $y=i+1$, while still preserving the validity of the current route. First, we first have to add an upstroke on the very left and a downstroke on the very right. Then, excluding the two at the endpoints of the mountain range, we notice that there are $a_{i+1}-1$ different locations where the current route hits $y=i+1$. These are the only locations that we can add strokes from $i$ to $i+1$ at, i.e. extending the route to hit $y=i$. This is achieved by adding two strokes \\/ (a wedge) at this location.

We have two cases: $a_i<{a_{i+1}}$ and $a_i\ge{a_{i+1}}$. For the first case, we can't add a wedge to every location, so we can only add at most one wedge at each location in order to minimize the number of direction changes. There's no point in adding two to a single location because the first wedge we add at each location adds $0$ direction changes, but all future ones add $2$ extra. We have $a_{i+1}-1$ possible locations, and $a_i-1$ wedges to add (because we spent one on the upstroke and downstroke at the ends of the mountain range). Therefore, $dp[i]=dp[i+1]*{{a_{i+1}-1}\choose{a_i-1}}$.

For the second case, we add at least one wedge to every location, and at least zero wedges on the endpoints of the mountain range. To get around this, we can count the endpoints of the mountain range as locations as well (so add $2$ to the current number of locations), and add a corresponding downstroke to the upstroke at the beginning and an upstroke to the downstroke at the end, such that both of them become wedges. This is equivalent to increasing the number of wedges to add by $1$, because we add two extra strokes. Then, we can say that we want to add at least one wedge to every single location. By stars and bars, we have $a_i+1$ total wedges to add and $a_{i+1}+1$ locations, and thus $dp[i]=dp[i+1]*{a_i\choose{a_{i+1}}}$.

Aside from the binomial coefficient precalculation which takes $O((\max{a_i})log(MOD))$, the base calculation takes $O(N)$.
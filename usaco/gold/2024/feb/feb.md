# USACO Gold 2024 February

## 1. Bessla Motors
This problem actually feels so depressed because the problem statement is so confusing and the solution is pretty unoriginal as well. Now I originally thought the problem allowed recharging at stations, so I crafted a solution using DSU and Dijkstra that would merge together separate paths, and then another, completely rewritten solution that did the same thing but explicitly stored the paths. Both obviously failed, because your understanding of the problem is supposedly to be "just see if there are K stations within distance R from each travel destination". Unfortunately the extra text about charging stations misconstrued the entire problem statement, at least for me. Yeah so after this the problem is just really boring, yet I still managed to waste a considerable amount of time on it. You basically simulate an $O(CMlogN)$ brute-force algorithm and store the reachable charging stations from each node but skip over iterations when the node already has $K$ distinct reachable stations. So $O(KMlogN)$ with a total of $CMlogN$ iterations, okok.

I'm not sure if the problem is solvable if you can recharge at stations, because there's no test data, but if anyone wants to challenge my solution in the bessla_motors_bad file then feel free.

## 2. Milk Exchange
A cow with initial bucket capacity $a_i$ will only lose milk when it reaches a bucket with a lower capacity. These are the nearest smaller values, which we can calculate with a stack. Then it holds that when pushing a new element into the stack, all the current buckets in the stack are where this bucket will lose milk (i.e. the first bucket in the stack is this bucket's nearest smaller value, the second bucket is the first bucket's nearest smaller value, etc., so these buckets are the locations where the current bucket will lose milk). The circular transition of milk buckets entails removals from our stack (so a deque), but we can avoid having to remove buckets by cleverly starting our iteration from the cow with the minimum $a_i$. 

Still, the algorithm takes $O(N^2)$. We have to go through the whole stack for every new addition, to mark the times at which this bucket loses milk. The solution (now that I realize, is kind of like lazy propagation) is to note that for two buckets $i$ and $j$, all buckets lose $a_i-a_j$ milk while $i$ and $j$ are adjacent in the stack. They will be adjacent for a range of minutes $[a,b]$, so that means we lose $a_i-a_j$ milk in each minute from $a...b$ (to find the range $[a,b]$, instead keep track of the range of indices such that $i$ and $j$ are adjacent, and it's easy to calculate the range of minutes from this). Thus, we can just update this range with prefix sums after $i$ and $j$ are no longer adjacent in the stack (they are no longer adjacent when $i$ is removed from the stack). The runtime complexity is $O(N)$, surprisingly (I originally didn't think this problem was solvable).
# USACO Gold 2020 December

## 1. Replication
Simplify the grid down to having only one $S$ position. Consider what happens in the first $D$ minutes, before the first replication. Any square within distance $D$ of the starting position will be reachable, which we can calculate with BFS. To extend the problem to having as many $S$ positions as possible, just do a multisource BFS. 

In fact this goes for every block of $D$ minutes. If you are at position ($x$,$y$) and have replicated $K$ times already, then you will still do BFS from this position, considering the centers of each group. But there is the extra detail that you need to check if any rocks are in the current group of robots. To do this, let's see if the closest rock to the center of the group is within distance $K$: if it is then there is a rock inside the group. Find the closest rocks to all positions with a BFS in $O(N^2)$. 

Also, note that we only care about the earliest time we get to any position. There is no benefit to backtracking to an already visited position to replicate there (it's a bit difficult to see imo, but think about it). Following this, we have our second BFS which runs in $O(N^2)$ as well.

After this we have for every position the earliest time we get to it, which effectively tells us how large the group is at that position. We must find the union of all these groups; any square inside the union will contribute to the answer. To find the union we'll do a third BFS. For a given group that has gone through $K$ replications, we will mark the center as distance $K$, the four squares around it as distance $K-1$ (i.e. the robots that were added at the first replication), the ones around them as $K-2$, etc (denoted $R$). Then our BFS sources are the centers of each group and we want to find the maximum $R$ for every square. When we go to each node's neighbors their distance is $R-1$. When $R$ is $0$, then we'll obviously stop. At the end, any node with a non-infinite distance contributes to the answer. (to implement this efficiently I maintain a queue and a sorted vector, so $O(N^2+N^2log(N^2))$. Also there is the caveat where a group of robots may move at a time that's a multiple of $D$ without issue, but after replication will collide with rocks.) 

Anyways, the complexity is $O(N^2+N^2log(N^2))$ (although there's a noticeable coefficient on the $N^2$ with all the BFS and queue additions).

## 2. Bovine Genetics
Ok I half-looked at the editorial to check my dp state and transitions, and it turns out I got it all right despite being the most complex state I have ever thought of. So I count it as solving by myself. Also, this contest is so difficult (see comments at bottom).

We wil take the final string and go in the reverse order: split the genome arbitrarily, reverse each of the pieces, and then concatenate them together to get a candidate for the original genome. Valid partitions must satisfy these properties: the first letter of each piece is equal to the last letter of the next piece (so that they are adjacent equal characters after reversal), and each piece must not contain any adjacent equal characters (if they did, then those would be splitting points as well). 

Partitioning into pieces is a task best done by dp. So, $dp[i][c]$ is the amount of ways to split the string up to $i$, assuming the first character of the last piece is $c$. When transitioning, $dp[i][c]$ can transition from any of $dp[j][c_2]$ for $j<i$ and any color $c_2$. The character at $i$ must be equal to $c_2$, and the character at $j+1$ must equal $c$. The string $[j+1,l]$ also must not contain adjacent duplicates. Specifically, add $dp[j][c_2]*f(j+1,i,c,c_2)$ where $f(l,r,c,c_2)$ is the amount of distinct possibilities for the string $[l,r]$, such that the first character is $c$, the last is $c_2$, and there are no adjacent duplicates. $f$ can be done with another dp, bringing the runtime to $O(|S|^2)$.

The least reducible dp is on $f$ because it has $O(N^2)$ calculation, so we should get rid of it by combining it into the normal dp. To do this, we need to consider the transitions for $f$. One of them is as follows: if we're trying to calculate $f[l][r][c][c_2]$, then we add $f[l][r-1][c][c_3]$ for $c_2\ne{c_3}$ (also, for the last character to be $c_2$, $c_2$ must be a valid candidate for the character at position $r$). This is because we extend the range $[l,r-1]$ to $[l,r]$ by adding $c_2$, meaning the last character of $[l,r-1]$ cannot be equal to $c_2$ (otherwise there are adjacent duplicates). Therefore, we just add $f[l][r-1][c][c_3]$. This observation lets us repurpose our original dp.

Redefine $dp[i][c][c_2][c_3]$ as the amount of ways to pick a valid sequence up to index $i$, with the first character of the last piece as $c$, the first character of the current piece as $c_2$, and the last character of the current piece as $c_3$. Then we have two transitions: either extend the current piece, or end the current piece (if possible) and start a new one. Extending the current piece just follows the logic from the above paragraph: $dp[i][c][c_2][c_3]$ is equal to the sum of $dp[i-1][c][c_2][c_4]$ for $c_3\ne{c_4}$ ($c_3$ must also be a valid candidate for the char at position $i$). The second transition is to end the current piece at index $i-1$ and start a new piece at index $i$. This is only possible if the first character of the last piece is equal to the last character of the current piece. Also, the new piece is of size $1$, so the first character $c_2$ is equal to the last character $c_3$. Therefore, change $dp[i][x][c_2][c_2]$ by adding the sum of $dp[i-1][c][x][c]$.

The base cases are $dp[1][c][c_2][c_2]=1$ if $c_2$ is a valid candidate for the first character of the string. The answer is the sum of $dp[|S|][c][c_2][c]$. And finally, the runtime is $O(|S|)$.

## 3. Square Pasture
Same concept as the editorial but implemented less elegantly. The problem is solved similarly to Rectangular Pasture but with more care needed to make the pasture a square shape, so solve that first.

For a given subset of cows, find the strictest rectangle (denote the size $W*H$) that contains all cows in this set. This is what we found for Rectangular Pasture. Now, we need to find, if this is extended to a square of side length $max(W,H)$, then if no new cows will be added into the set.

If $W>H$, then we can swap all x and y coordinates and rerun the algorithm. For a rectangle then, we must find out if the square of size $H*H$ will contain any new cows. This can be done by storing the closest cows to the left and right of the rectangle. These are the strictest candidates when the rectangle becomes a square, so just check if the distance between them minus $2$ is greater than/equal to $H$. 

So first, iterate over all pairs of cows ($i$ and $j$). I will call the rectangle formed by $i$ and $j$ the initial rectangle, $I$. When this rectangle is extended infinitely in the y-axis, call it the bounding rectangle, $B$. Then, for each cow such that is in $B$ and below $I$, find the cow (in $B$, above $I$) with the maximum y-value such that a valid square can still be formed. It should hold that valid squares can also be formed with all cows (in $B$, above $I$) with a lower y-coordinate than this cow. This can be accomplished with a 2p algorithm in $O(N^3)$.

## Comments:
Square Pasture, Replication, Bovine Genetics is my order of difficulty easiest to hardest, and each took me an average 2 hours to solve (order is 1-2 hours, 3 hours + editorial, 2 hours + half-editorial). Replication is my favorite because of the utility of bfs in the problem, including the final reverse-bfs at the end. I like Bovine Genetics next because the algorithm is very simple to implement after thinking, and the dp states are quite interesting (I was able to get to them through logical steps). Square Pasture is my least favorite; the silver version is more fun and this is just a less-interesting extension.
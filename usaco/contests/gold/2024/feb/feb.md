# USACO Gold 2024 February

## 1. Bessla Motors
This problem actually feels so depressed because the problem statement is so confusing and the solution is pretty unoriginal as well. Now I originally thought the problem allowed recharging at stations, so I crafted a solution using DSU and Dijkstra that would merge together separate paths, and then another, completely rewritten solution that did the same thing but explicitly stored the paths. Both obviously failed, because your understanding of the problem is supposedly to be "just see if there are K stations within distance R from each travel destination". Unfortunately the extra text about charging stations misconstrued the entire problem statement, at least for me. Yeah so after this the problem is just really boring, yet I still managed to waste a considerable amount of time on it. You basically simulate an $O(CMlogN)$ brute-force algorithm and store the reachable charging stations from each node but skip over iterations when the node already has $K$ distinct reachable stations. So $O(KMlogN)$ with a total of $CMlogN$ iterations, okok.

I'm not sure if the problem is solvable if you can recharge at stations, because there's no test data, but if anyone wants to challenge my solution in the bessla_motors_bad file then feel free.

## 2. Milk Exchange
A cow with initial bucket capacity $a_i$ will only lose milk when it reaches a bucket with a lower capacity. These are the nearest smaller values, which we can calculate with a stack. Then it holds that when pushing a new element into the stack, all the current buckets in the stack are where this bucket will lose milk (i.e. the first bucket in the stack is this bucket's nearest smaller value, the second bucket is the first bucket's nearest smaller value, etc., so these buckets are the locations where the current bucket will lose milk). The circular transition of milk buckets entails removals from our stack (so a deque), but we can avoid having to remove buckets by cleverly starting our iteration from the cow with the minimum $a_i$. 

Still, the algorithm takes $O(N^2)$. We have to go through the whole stack for every new addition, to mark the times at which this bucket loses milk. The solution (now that I realize, is kind of like lazy propagation) is to note that for two buckets $i$ and $j$, all buckets we iterate through while $i$ and $j$ are adjacent in the stack will at some point lose $a_i-a_j$ milk. $i$ and $j$ will be adjacent for a range of indices $[a,b]$, so that means we lose $a_i-a_j$ milk for each bucket from $a\dots{b}$. Because the indices form a continuous range, then we can easily find the range of minutes $[c,d]$ such that we lose $a_i-a_j$ milk every minute in the range $c\dots{d}$. Thus, we can just update this range with prefix sums once $i$ and $j$ are no longer adjacent in the stack (they are no longer adjacent when $i$ is removed from the stack). The runtime complexity is $O(N)$, surprisingly (I originally didn't think this problem was solvable).

## 3. Quantum Moochanics
A greedy algorithm works: repeatedly find the pair of adjacent particles that collide at the earliest observation time and delete them. The collision times between all currently adjacent particles can be stored in a set, which would run in $O(NlogN)$. Once you delete a pair of particles, the two particles to the left and right of this pair are now adjacent, so you have to update them. But, all this implies calculating the collision time between two particles in $O(1)$. 

A method is as follows: First note that for a pair of adjacent particles $i$ and $j$, then after observation $X$, particle $i$ moves $\lceil{X\over{2}}\rceil *s_i$ distance towards particle $j$, and particle $j$ moves $\lceil{X\over{2}}\rceil *s_j$ distance towards particle $i$. So they collide after some observation $X$ if the total distance traveled is greater than or equal to the distance between the particles. More formally, ${\lceil{X\over{2}}\rceil s_i}+{\lceil{X\over{2}}\rceil s_j}\ge{p_j-p_i}$. Therefore, ${\lceil{X\over{2}}\rceil}\ge{{p_j-p_i}\over{s_i+s_j}}$, so the minimum value is for ${\lceil{X\over{2}}\rceil}$ is $\lceil{{p_j-p_i}\over{s_i+s_j}}\rceil$. If particle $i$ is a mootrino then $X$ is odd, so multiply ${\lceil{X\over{2}}\rceil}$ by $2$ and subtract $1$. Otherwise, if particle $i$ is an antimootrino, then $X$ is even, so just multiply by $2$.
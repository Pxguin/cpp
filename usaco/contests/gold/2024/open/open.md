# USACO Gold 2024 US Open

## 1. Cowreography
Looked at solution (for the greedy strategy...) but at least I'm getting better

The initial string is $s$ and the final string is $t$. Let's say that a cow is moving from position $i$ to position $j$. In this case, we want to constantly swap it with cows of the other breed. The minimum number of moves is always going to equal $\lceil{{|j-i|}\over{K}}\rceil$, because we always swap this cow $K$ positions to the right each move. If it ever would land in a position occupied by a cow of the same breed, then we could first swap that cow into $j$, then swap this cow into this position. TLDR; it's effectively the same thing as replacing this cow with that cow. 

We can match each $1$ at index $i$ in the original string to some $1$ at index $j$ in the final string. If $i<j$ then this cow must move right, and otherwise it must move left. If all cows move in the same direction, then the answer is the sum of $\lceil{{|j_k-i_k|}\over{K}}\rceil$ for all cows $k$. We can generalize further: if no left-moving and right-moving cow cross paths (they cross if the $[i,j]$ ranges intersect), then we can split up all cows into disjoint left-moving and right-moving components. For each component, we can calculate the min number of moves independently, so the final result across all components is still $\lceil{{|j_k-i_k|}\over{K}}\rceil$. Generalize further. If a left-moving and right-moving cow cross paths, then just swap their $j$ values such that they don't cross paths anymore. It is intuitive that this won't worsen the answer, and may even improve it. Thus, we can say that the optimal assignment splits cows into disjoint left-moving and right-moving components, and so the minimum number of moves is exactly $\lceil{{|j_k-i_k|}\over{K}}\rceil$.

However, we still have to explicitly find an optimal assignment. Note that the only cows considered for assignment are at indices $i$ such that $s_i\ne{t_i}$. If $s_i=1$ and $t_i=0$, then refer to this as a start index. If $s_i=0$ and $t_i=1$, then it's an end index. A valid assignment pairs up start and end indices together.

Now I'll assume WLOG that there's only one component and that all cows move right. This means that we'll match up each start index with an end index further to the right. Also, scan left-to-right.

For some end index $j$, let's consider the set of unassigned start indices $i$ so far. It should be clear that if there's a start index of a distance divisible by $K$ away from this end index ($j-i$ is divisible by $K$), then it's optimal to assign $j$ to that start index. Generalizing, let $x_i$ be the smallest number of the form $i+MK$ that is $\ge{j}$, for $M\in\Z$. We want to assign $j$ to the minimum $x_i$, as this $i$ is the most restrictive to satisfy any future $j$ with (because it's the closest to $j$).

Summarizing the algorithm: go through each component. I'll assume the current component is a right-moving one. Scan left to right and store an array $A$, which contains all unassigned start indices. Before processing index $i$, go through all indices in the array and add $K$ to them if they are less than $i$, which is the equivalent of swapping that cow $K$ to the right. Because we're adding a swap, add $1$ to the answer. This addition process is to ensure that all indices are $\ge{i}$, in order to get the minimum value of $i+MK$. Then if $i$ is a start index, add it to $A$, and if it's an end index, assign it to the smallest element in $A$ and remove that element. To efficiently do this in $O(N)$, we can compress the list into $\set{index,frequency}$ pairs and process all operations in a deque (see code for details).

## 2. Grass Segments
Ok so two segments either are disjoint, intersecting at one endpoint, or one contains the other. So this means that the answer for segment $i$ is the amount of segments starting to the left of $i$ and ending $>= l_i + k_i$, plus the # starting to the right and ending $<= r_i-k_i$, minus the segments containing $i$, plus the segments contained by $i$ with size $>= k_i$. Yeah also the last part is impossible to do efficiently. 

With complementary counting, we get rid of double counting the segments containing $i$ (and some extra double counting as we will see later). Now, it's just $N - ($ the # of segments starting to the left of $i$ and ending $< l_i + k_i$, plus the # starting to the right and ending $> r_i-k_i$, plus the amount of segments contained by $i$ with size $< k_i)$. We see the problematic last part appear again, but just iterate over $k_i$ in descending order, and build an indexed set/order statistic tree (or binary indexed tree with coordinate compression) containing all segments with size $> k_i$. We basically limit ourselves to this monotonically growing set of ranges. Thus we ensure that any segment containing, or contained by $i$ will have size $\ge k$ and we don't have to deal with them. 

FIX THE ISSUES RN
Complexity: $O(NlogN)$

## 3. Smaller Averages
Yeah, I'm glad that I solved this one completely by myself.

We can quickly generate an $O(N^4)$ dp by denoting $dp[i][j]$ as the amount of ways to split $[a_1,a_i]$ and $[b_1,b_j]$. Let a function $A(i,j,k,l)$ return if the average for $[a_i,a_j]$ is smaller than or equal to the average for $[b_k,b_l]$. Now for base cases, $dp[i][j]=1$ if $A(1,i,1,j)$ returns true; otherwise $dp[i][j]=0$. For transitions, we try all possibilities of adding the next range in $a$ and the next range in $b$, so transitions take $O(N^2)$ (with prefix sums) and the whole algorithm takes $O(N^4)$.

We'll speed up the transitions. Instead of $dp[i][j]$ transitioning to $dp[i'][j']$ with $i'>i$ and $j'>j$ (push dp for $a$ range, push dp for $b$ range), we'll use push dp for the $a$ range and pull dp for the $b$ range. This means that when we're processing $dp[i][j]$, we'll transition to $dp[i'][j]$ ($i'>i$) by considering all $dp[i][j']$ ($j'<j)$, and check if $A(i,i',j',j)$ is true. If it's true, then we'll add $dp[i][j']$ to $dp[i'][j]$.

Naively transitioning still takes $O(N^2)$, but we can reduce to $O(NlogN)$. We can do this by having preprocessed all ranges $[j',j]$ (sorted by average), and then binary search on the sorted array for each $i'$ to find which elements the average of $[i,i']$ is smaller than or equal to. If we have calculated prefix sums for the sorted array, then we can quickly get the sum of all dp values that we can transition from, and add it to $dp[i'][j]$. Processing each $i'$ takes $O(logN)$ and there are up to $N$ values of $i'$ to consider, so $O(NlogN)$ transitions for a total complexity of $O(N^3logN)$.

This can be reduced further to $O(N^3)$. We transition to all $i'>i$, so we can also preprocess ranges $[i,i']$ and sort by average, then just use two pointers on the $[i,i']$ array and the $[j',j]$ array to get the value for each $dp[i'][j]$ in $O(1)$ time. At the end, return $dp[N][N]$.
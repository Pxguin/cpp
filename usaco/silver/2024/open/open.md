# USACO Silver 2024 US Open

## 1. Bessie's Interview
We can first just simulate the process. If two farmers finish at the same time, we'll arbitrarily pick one. Let the farmer that picks Bessie to be farmer $B$, finishing at time $T$. But if there was a farmer that just finished interviewing at the same time as farmer $B$, then that farmer is also a for interviewing Bessie. Generalizing this, for any farmers that finished interviewing simultaneously, they are candidates. So we know the final farmer and all candidates for it; we'll now go backwards to consider all previous events.

$For any farmers $K$ that finished interviewing at the same time (at times $T$) as farmer $B$, each of them could have interviewed Bessie. Ay farmers that finished with those farmers before time $T$ could also have taken the spot of farmer K. Therefore, those farmers are also viable candidates. We would repeat this process on those farmers over and over again to find all possible farmers.

Do this by connecting two farmers $i$ and $j$ with an edge with weight $t$, given that at time $t$ they simultaneously finish interviewing a cow. Let's say that farmers $1,2,3$ all finish at some time. To avoid drawing an edge between every pair of farmers, which could amount to $N^2$ edges, just draw $1\rightarrow{2}$ and $2\rightarrow{3}$. All farmers are still reachable this way. After this, start from node $B$ and go through the graph. If there is an edge with weight $\le T$, then that farmer is ok. Generalizing this, find the maximum time that each farmer can become a candidate. Assume it's $t_i$; in this case, we can only traverse edges from this node with time $\le{t_i}$. Use a small modification of Dijkstra to calculate.

Time complexity: The initial simulation takes $O(NlogK)$ and there are at most $N$ edges, so the runtime is $O(Nlog(N+K))$.

The extension: I think just count the number of adjacent edges for each farmer $i$ such that it's $\le{t_i}$; this is the weight of the farmer and you can compute probability this way (but not tested).

## 3. The 'Winning' Gene
I actually said that I would never do this problem, but I ended up solving it today for no reason.

The difficulty is figuring out the order of iteration. First, iterate over $L$. For each substring $i$ of length $L$, find the maximum length $k$-mer such that this is the last string in the $k$-mer, and such that it's lex. min. This maximum length is $l_i$. Do the same this on the right, such that this string is the first string in the $k$-mer and such that it's lex. min. Call this $r_i$. Now, it can be said that for any string inside the range [$l_i,r_i$] containing $i$, string $i$ is the lex. min string. So the position of $i$ contributes to any $K$ satisfying $L\le{K}\le{l_i+r_i}$. Sum all the ranges with difference arrays to find the value of $(K,L)$ for each $K$, and add it to the answer. The time complexity is $O(N^2)$, but only after some other things get sorted out.

First: finding $l_i$ and $r_i$. This can be done with a 2p/dp algorithm, but it requires us to compare two strings in $O(1)$. Do this by going through each pair of indices $(i,j)$ and storing the minimum length $s$ such that the string $[i,i+s-1]$ is not equal to the string $[j,j+s-1]$; i.e. length of LCP plus $1$. This allows us to compare any two strings of the same length. This is done through an algorithm for which it's helpful to know dp (see Gold Minimum Longest Trip). 

Bad explanations, but here are the details:
 - Finding $l_i$: $l_i$ is the max length to the left of string $i$ such that $i$ is lex min in the range. Let the index that the range ends at be $p_i$; i.e, $i-l_i$. It's easier to calculate $p_i$, then find $l_i$ by subtracting $p_i$ from $i$. So, we'll iterate over $i$ in increasing order. Assume we've calculating $p_j$ for $p<i$, and now we're calculating $p_i$. First, initialize it to $i$. Then, while the string of length $L$ starting at index $i$ is lexicographically smaller than the string of length $L$ starting at index $p_i-1$, update $p_i$ to $p_{p_i-1}$. This is because if it's lex smaller than the string at $p_i-1$, then it must be lex smaller than anything in the range for index $p_i-1$, so we can ignore comparing to all strings in the range. This only takes $O(N)$ because all ranges must be disjoint or contained inside each other. The amount of iterations we do for each $i$ is the amount of disjoint ranges contained inside its range. So, once a range is contained inside another range then it won't be considered anymore. Thus, $O(N)$.
 - Doing the lex min dp: for computing $lex[i][j]$, $lex[i][j]=1$ if the characters at $i$ and $j$ are different. Otherwise, it's $lex[i+1][j+1]+1$. I wanted to use string hashing at first but the time complexity doesn't allow

Bonus: Instead of writing down the $0$-indexed position in $S$, Farmer John writes down the $0$-indexed position in the $k$-mer. Solve the problem but with this modification.